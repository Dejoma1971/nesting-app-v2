(function(){"use strict";const J=s=>s*Math.PI/180,K=(s,t,i)=>{const f=t.x-s.x,e=t.y-s.y,r=Math.sqrt(f*f+e*e)*(1+i*i)/(4*Math.abs(i)),o=(s.x+t.x)/2-e*(1-i*i)/(4*i),g=(s.y+t.y)/2+f*(1-i*i)/(4*i);return{radius:r,cx:o,cy:g}},Q=s=>{const t=[];let i=[...s];for(;i.length>0;){const f=i.find(r=>!r.used);if(!f)break;const e=[];f.used=!0,f.points.forEach(r=>e.push(r));let h=!0;for(;h;){h=!1;const r=e[e.length-1];for(const o of i){if(o.used)continue;const g=Math.hypot(o.start.x-r.x,o.start.y-r.y),k=Math.hypot(o.end.x-r.x,o.end.y-r.y);if(g<.01){for(let E=1;E<o.points.length;E++)e.push(o.points[E]);o.used=!0,h=!0;break}else if(k<.01){const E=[...o.points].reverse();for(let b=1;b<E.length;b++)e.push(E[b]);o.used=!0,h=!0;break}}}e.length>2&&t.push(e),i=i.filter(r=>!r.used)}return t},Z=(s,t)=>{const i=[],e=(d,c,L)=>{d.forEach(n=>{if(n.type==="INSERT"&&n.name&&s.blocks){const l=s.blocks[n.name];l&&l.entities&&e(l.entities,c+(n.position?.x||0),L+(n.position?.y||0));return}const M=[];if(n.type==="LINE"||n.type==="LWPOLYLINE"||n.type==="POLYLINE"){if(n.vertices&&n.vertices.length>0)for(let l=0;l<n.vertices.length;l++){const y=n.vertices[l],Y=l===n.vertices.length-1;if(n.type==="LINE"&&Y){M.push({x:y.x+c,y:y.y+L});continue}if(n.type!=="LINE"&&Y){M.push({x:y.x+c,y:y.y+L});continue}const N=n.vertices[l+1];if(M.push({x:y.x+c,y:y.y+L}),y.bulge&&y.bulge!==0){const m={x:y.x+c,y:y.y+L},V={x:N.x+c,y:N.y+L},{radius:O,cx:G,cy:U}=K(m,V,y.bulge),$=Math.atan2(m.y-U,m.x-G),H=4*Math.atan(y.bulge),z=Math.max(2,Math.floor(24*(Math.abs(H)/(2*Math.PI))));for(let D=1;D<z;D++){const F=$+D/z*H;M.push({x:G+O*Math.cos(F),y:U+O*Math.sin(F)})}}}}else if(n.type==="CIRCLE"){if(n.center&&n.radius!==void 0){const l=n.radius,y=n.center.x+c,Y=n.center.y+L;for(let N=0;N<=24;N++){const m=N/24*2*Math.PI;M.push({x:y+l*Math.cos(m),y:Y+l*Math.sin(m)})}}}else if(n.type==="ARC"&&n.center&&n.radius!==void 0){const l=n.radius,y=n.center.x+c,Y=n.center.y+L,N=n.startAngle||0;let m=n.endAngle||2*Math.PI;m<N&&(m+=2*Math.PI);const V=m-N,O=Math.max(2,Math.floor(24*(V/(2*Math.PI))));for(let G=0;G<=O;G++){const U=N+G/O*V;M.push({x:y+l*Math.cos(U),y:Y+l*Math.sin(U)})}}M.length>1&&i.push({points:M,start:M[0],end:M[M.length-1],used:!1})})};s.entities&&e(s.entities,0,0);const h=Q(i);h.length===0&&h.push([{x:0,y:0},{x:s.width,y:0},{x:s.width,y:s.height},{x:0,y:s.height}]);let r=1/0,o=1/0,g=-1/0,k=-1/0;h.forEach(d=>{d.forEach(c=>{c.x<r&&(r=c.x),c.x>g&&(g=c.x),c.y<o&&(o=c.y),c.y>k&&(k=c.y)})});const E=g-r,b=k-o,C=r+E/2,u=o+b/2,x=J(t.rotation),a=Math.cos(x),p=Math.sin(x),I=t.rotation%180!==0?b:E,S=t.rotation%180!==0?E:b,w=t.x+I/2,R=t.y+S/2,P=h.map(d=>d.map(c=>{const L=c.x-C,n=c.y-u,M=L*a-n*p,l=L*p+n*a;return{x:M+w,y:l+R}}));let v=P[0],A=[];if(P.length>1){let d=-1,c=0;P.forEach((L,n)=>{let M=1/0,l=-1/0,y=1/0,Y=-1/0;L.forEach(m=>{m.x<M&&(M=m.x),m.x>l&&(l=m.x),m.y<y&&(y=m.y),m.y>Y&&(Y=m.y)});const N=Math.hypot(l-M,Y-y);N>d&&(d=N,c=n)}),v=P[c],A=P.filter((L,n)=>n!==c)}else v=P[0];let _=1/0,B=1/0,X=-1/0,T=-1/0;return v.forEach(d=>{d.x<_&&(_=d.x),d.x>X&&(X=d.x),d.y<B&&(B=d.y),d.y>T&&(T=d.y)}),{uuid:t.uuid,outer:v,holes:A,bounds:{minX:_,maxX:X,minY:B,maxY:T}}},j=(s,t)=>{let i=!1,f=0,e=t.length-1;for(;f<t.length;e=f++)t[f].y>s.y!=t[e].y>s.y&&s.x<(t[e].x-t[f].x)*(s.y-t[f].y)/(t[e].y-t[f].y)+t[f].x&&(i=!i);return i},q=(s,t)=>{if(!j(s,t.outer))return!1;for(const i of t.holes)if(j(s,i))return!1;return!0},W=(s,t,i,f)=>{const e=(C,u)=>({x:C.x-u.x,y:C.y-u.y}),h=(C,u)=>C.x*u.y-C.y*u.x,r=e(t,s),o=e(f,i),g=h(r,o),k=h(e(i,s),r);if(g===0&&k===0||g===0&&k!==0)return!1;const E=h(e(i,s),o)/g,b=h(e(i,s),r)/g;return E>=0&&E<=1&&b>=0&&b<=1};self.onmessage=s=>{const{placedParts:t,partsData:i,binWidth:f,binHeight:e,margin:h,cropLines:r}=s.data,o=[],g=new Map;t.forEach(u=>{const x=i.find(a=>a.id===u.partId);if(x){const a=Z(x,u);g.set(u.uuid,a)}});const k=h,E=f-h,b=h,C=e-h;t.forEach(u=>{const x=g.get(u.uuid);if(x&&!(x.bounds.minX>=k&&x.bounds.maxX<=E&&x.bounds.minY>=b&&x.bounds.maxY<=C)){for(const a of x.outer)if(a.x<k-.01||a.x>E+.01||a.y<b-.01||a.y>C+.01){o.includes(u.uuid)||o.push(u.uuid);break}}}),r&&r.length>0&&t.forEach(u=>{if(o.includes(u.uuid))return;const x=g.get(u.uuid);if(x)for(const a of r){let p,I;a.type==="vertical"?(p={x:a.position,y:0},I={x:a.position,y:e}):(p={x:0,y:a.position},I={x:f,y:a.position});const S=[x.outer,...x.holes];let w=!1;t:for(const R of S)for(let P=0;P<R.length;P++){const v=R[P],A=R[(P+1)%R.length];if(W(v,A,p,I)){w=!0;break t}}if(w){o.push(u.uuid);break}}});for(let u=0;u<t.length;u++)for(let x=u+1;x<t.length;x++){const a=t[u],p=t[x];if(o.includes(a.uuid)&&o.includes(p.uuid))continue;const I=g.get(a.uuid),S=g.get(p.uuid);if(!I||!S||I.bounds.maxX<S.bounds.minX||I.bounds.minX>S.bounds.maxX||I.bounds.maxY<S.bounds.minY||I.bounds.minY>S.bounds.maxY)continue;let w=!1;const R=[I.outer,...I.holes],P=[S.outer,...S.holes];t:for(const v of R)for(let A=0;A<v.length;A++){const _=v[A],B=v[(A+1)%v.length];for(const X of P)for(let T=0;T<X.length;T++){const d=X[T],c=X[(T+1)%X.length];if(W(_,B,d,c)){w=!0;break t}}}if(!w){const v=I.outer[0];if(q(v,S))w=!0;else{const A=S.outer[0];q(A,I)&&(w=!0)}}w&&(o.includes(a.uuid)||o.push(a.uuid),o.includes(p.uuid)||o.push(p.uuid))}self.postMessage(o)}})();
