(function(){"use strict";const J=s=>s*Math.PI/180,K=(s,n,i)=>{const l=n.x-s.x,e=n.y-s.y,r=Math.sqrt(l*l+e*e)*(1+i*i)/(4*Math.abs(i)),o=(s.x+n.x)/2-e*(1-i*i)/(4*i),M=(s.y+n.y)/2+l*(1-i*i)/(4*i);return{radius:r,cx:o,cy:M}},Q=s=>{const n=[];let i=[...s];for(;i.length>0;){const l=i.find(r=>!r.used);if(!l)break;const e=[];l.used=!0,l.points.forEach(r=>e.push(r));let h=!0;for(;h;){h=!1;const r=e[e.length-1];for(const o of i){if(o.used)continue;const M=Math.hypot(o.start.x-r.x,o.start.y-r.y),k=Math.hypot(o.end.x-r.x,o.end.y-r.y);if(M<.01){for(let E=1;E<o.points.length;E++)e.push(o.points[E]);o.used=!0,h=!0;break}else if(k<.01){const E=[...o.points].reverse();for(let L=1;L<E.length;L++)e.push(E[L]);o.used=!0,h=!0;break}}}e.length>2&&n.push(e),i=i.filter(r=>!r.used)}return n},Z=(s,n)=>{const i=[],e=(d,c,b)=>{d.forEach(t=>{if(t.type==="INSERT"&&t.name&&s.blocks){const f=s.blocks[t.name];f&&f.entities&&e(f.entities,c+(t.position?.x||0),b+(t.position?.y||0));return}const g=[];if(t.type==="LINE"||t.type==="LWPOLYLINE"||t.type==="POLYLINE"){if(t.vertices&&t.vertices.length>0)for(let f=0;f<t.vertices.length;f++){const y=t.vertices[f],Y=f===t.vertices.length-1;if(t.type==="LINE"&&Y){g.push({x:y.x+c,y:y.y+b});continue}if(t.type!=="LINE"&&Y){g.push({x:y.x+c,y:y.y+b});continue}const N=t.vertices[f+1];if(g.push({x:y.x+c,y:y.y+b}),y.bulge&&y.bulge!==0){const m={x:y.x+c,y:y.y+b},V={x:N.x+c,y:N.y+b},{radius:O,cx:G,cy:U}=K(m,V,y.bulge),$=Math.atan2(m.y-U,m.x-G),H=4*Math.atan(y.bulge),z=Math.max(2,Math.floor(24*(Math.abs(H)/(2*Math.PI))));for(let D=1;D<z;D++){const F=$+D/z*H;g.push({x:G+O*Math.cos(F),y:U+O*Math.sin(F)})}}}}else if(t.type==="CIRCLE"){if(t.center&&t.radius!==void 0){const f=t.radius,y=t.center.x+c,Y=t.center.y+b;for(let N=0;N<=24;N++){const m=N/24*2*Math.PI;g.push({x:y+f*Math.cos(m),y:Y+f*Math.sin(m)})}}}else if(t.type==="ARC"&&t.center&&t.radius!==void 0){const f=t.radius,y=t.center.x+c,Y=t.center.y+b,N=t.startAngle||0;let m=t.endAngle||2*Math.PI;m<N&&(m+=2*Math.PI);const V=m-N,O=Math.max(2,Math.floor(24*(V/(2*Math.PI))));for(let G=0;G<=O;G++){const U=N+G/O*V;g.push({x:y+f*Math.cos(U),y:Y+f*Math.sin(U)})}}g.length>1&&i.push({points:g,start:g[0],end:g[g.length-1],used:!1})})};s.entities&&e(s.entities,0,0);const h=Q(i);h.length===0&&h.push([{x:0,y:0},{x:s.width,y:0},{x:s.width,y:s.height},{x:0,y:s.height}]);let r=1/0,o=1/0,M=-1/0,k=-1/0;h.forEach(d=>{d.forEach(c=>{c.x<r&&(r=c.x),c.x>M&&(M=c.x),c.y<o&&(o=c.y),c.y>k&&(k=c.y)})});const E=M-r,L=k-o,C=r+E/2,a=o+L/2,x=J(n.rotation),u=Math.cos(x),S=Math.sin(x),I=E*Math.abs(u)+L*Math.abs(S),P=E*Math.abs(S)+L*Math.abs(u),w=n.x+I/2,R=n.y+P/2,p=h.map(d=>d.map(c=>{const b=c.x-C,t=c.y-a,g=b*u-t*S,f=b*S+t*u;return{x:g+w,y:f+R}}));let v=p[0],A=[];if(p.length>1){let d=-1,c=0;p.forEach((b,t)=>{let g=1/0,f=-1/0,y=1/0,Y=-1/0;b.forEach(m=>{m.x<g&&(g=m.x),m.x>f&&(f=m.x),m.y<y&&(y=m.y),m.y>Y&&(Y=m.y)});const N=Math.hypot(f-g,Y-y);N>d&&(d=N,c=t)}),v=p[c],A=p.filter((b,t)=>t!==c)}else v=p[0];let _=1/0,B=1/0,X=-1/0,T=-1/0;return v.forEach(d=>{d.x<_&&(_=d.x),d.x>X&&(X=d.x),d.y<B&&(B=d.y),d.y>T&&(T=d.y)}),{uuid:n.uuid,outer:v,holes:A,bounds:{minX:_,maxX:X,minY:B,maxY:T}}},j=(s,n)=>{let i=!1,l=0,e=n.length-1;for(;l<n.length;e=l++)n[l].y>s.y!=n[e].y>s.y&&s.x<(n[e].x-n[l].x)*(s.y-n[l].y)/(n[e].y-n[l].y)+n[l].x&&(i=!i);return i},q=(s,n)=>{if(!j(s,n.outer))return!1;for(const i of n.holes)if(j(s,i))return!1;return!0},W=(s,n,i,l)=>{const e=(C,a)=>({x:C.x-a.x,y:C.y-a.y}),h=(C,a)=>C.x*a.y-C.y*a.x,r=e(n,s),o=e(l,i),M=h(r,o),k=h(e(i,s),r);if(M===0&&k===0||M===0&&k!==0)return!1;const E=h(e(i,s),o)/M,L=h(e(i,s),r)/M;return E>=0&&E<=1&&L>=0&&L<=1};self.onmessage=s=>{const{placedParts:n,partsData:i,binWidth:l,binHeight:e,margin:h,cropLines:r}=s.data,o=[],M=new Map;n.forEach(a=>{const x=i.find(u=>u.id===a.partId);if(x){const u=Z(x,a);M.set(a.uuid,u)}});const k=h,E=l-h,L=h,C=e-h;n.forEach(a=>{const x=M.get(a.uuid);if(x&&!(x.bounds.minX>=k&&x.bounds.maxX<=E&&x.bounds.minY>=L&&x.bounds.maxY<=C)){for(const u of x.outer)if(u.x<k-.01||u.x>E+.01||u.y<L-.01||u.y>C+.01){o.includes(a.uuid)||o.push(a.uuid);break}}}),r&&r.length>0&&n.forEach(a=>{if(o.includes(a.uuid))return;const x=M.get(a.uuid);if(x)for(const u of r){let S,I;u.type==="vertical"?(S={x:u.position,y:0},I={x:u.position,y:e}):(S={x:0,y:u.position},I={x:l,y:u.position});const P=[x.outer,...x.holes];let w=!1;t:for(const R of P)for(let p=0;p<R.length;p++){const v=R[p],A=R[(p+1)%R.length];if(W(v,A,S,I)){w=!0;break t}}if(w){o.push(a.uuid);break}}});for(let a=0;a<n.length;a++)for(let x=a+1;x<n.length;x++){const u=n[a],S=n[x];if(o.includes(u.uuid)&&o.includes(S.uuid))continue;const I=M.get(u.uuid),P=M.get(S.uuid);if(!I||!P||I.bounds.maxX<P.bounds.minX||I.bounds.minX>P.bounds.maxX||I.bounds.maxY<P.bounds.minY||I.bounds.minY>P.bounds.maxY)continue;let w=!1;const R=[I.outer,...I.holes],p=[P.outer,...P.holes];t:for(const v of R)for(let A=0;A<v.length;A++){const _=v[A],B=v[(A+1)%v.length];for(const X of p)for(let T=0;T<X.length;T++){const d=X[T],c=X[(T+1)%X.length];if(W(_,B,d,c)){w=!0;break t}}}if(!w){const v=I.outer[0];if(q(v,P))w=!0;else{const A=P.outer[0];q(A,I)&&(w=!0)}}w&&(o.includes(u.uuid)||o.push(u.uuid),o.includes(S.uuid)||o.push(S.uuid))}self.postMessage(o)}})();
